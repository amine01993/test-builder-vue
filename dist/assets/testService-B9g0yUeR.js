import{D as L,r as C,c as g,u as B}from"./index-DgVFOuIu.js";import{u as j,d as x,g as k,c as w,q,o as R,b as y,e as z,T as D,f as A,h as G,i as V,w as F,a as W,l as N,s as X}from"./firestore-CKAN35Ge.js";import{Q as Y}from"./Question-DJVAB3JS.js";const O=L("choiceService",()=>{const{db:d}=j(),m=C(),h=C(),r=C(),n=C();async function f(v,l,a){var e;if(m.value===v&&h.value===l){const s=(e=n.value)==null?void 0:e.find(t=>t.id===a);if(s)return s}const o=x(d,"tests",v,"questions",l,"choices",a),u=await k(o);if(u.exists()){const s=u.data();return s.id=u.id,s}}async function P(v,l){const a=w(d,"tests",v,"questions",l,"choices"),o=q(a,R("position"));return(await y(o)).docs.map(e=>{const s=e.data();return s.id=e.id,s})}async function Q(v,l){if(!l.id||m.value===v&&h.value===l.id)return;m.value=v,h.value=l.id,r.value=l.choiceCount;const a=w(d,"tests",v,"questions",l.id,"choices"),o=q(a,R("position")),u=await y(o);n.value=u.docs.map(e=>{const s=e.data();return s.id=e.id,s})}async function T(v,l,a){var i;const{user:o}=B(),{updateMaxPoints:u}=E(),{updateChoiceCount:e,updateMaxPoints:s}=b();a.user_id=(i=o.value)==null?void 0:i.uid;const t=await z(w(d,"tests",v,"questions",l,"choices"),a);if(a.id=t.id,a.updated_at=D.fromDate(new Date),n.value){n.value.unshift(a);let c=0;for(;c+1<n.value.length;){if(n.value[c].position>n.value[c+1].position){const p=n.value[c];n.value[c]=n.value[c+1],n.value[c+1]=p}c++}}else n.value=[a];return r.value?r.value++:r.value=1,e(l,r.value),a.points&&a.points>0&&(s(l),u(v)),t}async function M(v,l,a,o){const{updateMaxPoints:u}=E(),{updateMaxPoints:e}=b();if(await A(x(d,"tests",v,"questions",l,"choices",a),{text:o.text,is_correct:o.is_correct,points:o.points,position:o.position}),n.value){const s=n.value.findIndex(t=>t.id===a);if(s>-1){const t=n.value[s];if(t.text=o.text,t.is_correct=o.is_correct,t.updated_at=D.fromDate(new Date),o.position>t.position){let i=s;for(;i+1<n.value.length;){if(o.position>n.value[i+1].position){const c=n.value[i];n.value[i]=n.value[i+1],n.value[i+1]=c}i++}}else if(o.position<t.position){let i=s;for(;i-1>=0;){if(o.position<n.value[i-1].position){const c=n.value[i];n.value[i]=n.value[i-1],n.value[i-1]=c}i--}}t.position=o.position,t.points!==o.points&&(t.points=o.points,e(l),u(v))}}}async function S(v,l){if(n.value){const a=n.value.map(u=>u.position);let o=0;for(;o+1<a.length;){if(a[o]>a[o+1]){const u=a[o];a[o]=a[o+1],a[o+1]=u}o++}for(const[u,e]of n.value.entries())if(e.position!==a[u]&&e.id){const s=x(d,"tests",v,"questions",l,"choices",e.id);await A(s,{position:a[u]}),e.position=a[u]}}}async function I(v,l,a){const{updateMaxPoints:o}=E(),{updateChoiceCount:u,updateMaxPoints:e}=b(),s=x(d,"tests",v,"questions",l,"choices",a);if(await G(s),n.value){const t=n.value.findIndex(i=>a===i.id);t>-1&&n.value.splice(t,1)}r.value?r.value--:r.value=0,u(l,r.value),e(l),o(v)}return{choiceCount:g(()=>r),choices:g(()=>n),getChoice:f,getChoices:P,loadChoices:Q,addChoice:T,updateChoice:M,updateChoicesPositions:S,deleteChoice:I}}),b=L("questionService",()=>{const{db:d}=j(),{getChoices:m}=O(),h=C(),r=C(),n=C();function f(a,o){var e;const u=(e=n.value)==null?void 0:e.find(s=>s.id===a);u&&(u.choiceCount=o)}function P(a){if(!n.value)return;const o=n.value.find(s=>s.id===a);if(!o)return;const{choices:u}=O();if(!u.value)return;let e=0;o.type===Y.MultipleChoice?e=u.value.reduce((s,t)=>s+(t.points??0),0):e=u.value.reduce((s,t)=>Math.max(s,t.points??0),0),o.max_points=e}async function Q(a,o){var s;if(h.value===a){const t=(s=n.value)==null?void 0:s.find(i=>i.id===o);if(t)return t}const u=x(d,"tests",a,"questions",o),e=await k(u);if(e.exists()){const t=e.data();return t.id=e.id,t}}async function T(a){const o=w(d,"tests",a,"questions"),u=q(o,R("position")),e=[];return(await y(u).then(t=>{const i=[];return t.forEach(c=>{if(c.exists()){const p=c.data();p.id=c.id,e.push(p),i.push(m(a,c.id))}}),Promise.all(i)})).forEach((t,i)=>{e[i].choices=t}),e}async function M(a){if(!a.id||h.value===a.id)return;h.value=a.id,r.value=a.questionCount;const o=w(d,"tests",a.id,"questions"),u=q(o,R("position")),e=await y(u);n.value=e.docs.map(s=>{const t=s.data();return t.id=s.id,t})}async function S(a,o){var t;const{user:u}=B(),{updateQuestionCount:e}=E();o.user_id=(t=u.value)==null?void 0:t.uid;const s=await z(w(d,"tests",a,"questions"),o);if(o.id=s.id,o.updated_at=D.fromDate(new Date),n.value){n.value.unshift(o);let i=0;for(;i+1<n.value.length;){if(n.value[i].position>n.value[i+1].position){const c=n.value[i];n.value[i]=n.value[i+1],n.value[i+1]=c}i++}}else n.value=[o];return r.value?r.value++:r.value=1,e(a,r.value),s}async function I(a,o,u){if(await A(x(d,"tests",a,"questions",o),{text:u.text,type:u.type,position:u.position}),n.value){const e=n.value.findIndex(s=>s.id===o);if(e>-1){const s=n.value[e];if(s.text=u.text,s.type=u.type,s.updated_at=D.fromDate(new Date),u.position>s.position){let t=e;for(;t+1<n.value.length;){if(u.position>n.value[t+1].position){const i=n.value[t];n.value[t]=n.value[t+1],n.value[t+1]=i}t++}}else if(u.position<s.position){let t=e;for(;t-1>=0;){if(u.position<n.value[t-1].position){const i=n.value[t];n.value[t]=n.value[t-1],n.value[t-1]=i}t--}}s.position=u.position}}}async function v(a){if(n.value){const o=n.value.map(e=>e.position);let u=0;for(;u+1<o.length;){if(o[u]>o[u+1]){const e=o[u];o[u]=o[u+1],o[u+1]=e}u++}for(const[e,s]of n.value.entries())if(s.position!==o[e]&&s.id){const t=x(d,"tests",a,"questions",s.id);await A(t,{position:o[e]}),s.position=o[e]}}}async function l(a,o){const{updateQuestionCount:u}=E(),e=x(d,"tests",a,"questions",o);if(await G(e),n.value){const c=n.value.findIndex(p=>o===p.id);c>-1&&n.value.splice(c,1)}r.value?r.value--:r.value=0,u(a,r.value);const s=V(d),t=w(d,"tests",a,"questions",o,"choices");(await y(t)).forEach(c=>{s.delete(c.ref)}),await s.commit()}return{questionCount:g(()=>r),questions:g(()=>n),getQuestion:Q,getQuestions:T,loadQuestions:M,addQuestion:S,updateQuestion:I,updateQuestionsPositions:v,updateChoiceCount:f,updateMaxPoints:P,deleteQuestion:l}}),E=L("testService",()=>{const{db:d}=j(),m=C(),h=C(),r=25;let n=null;const f=C(null),{deleteQuestion:P,getQuestions:Q}=b();function T(e,s){var i;const t=(i=f.value)==null?void 0:i.find(c=>c.id===e);t&&(t.questionCount=s)}function M(e){if(!f.value)return;const s=f.value.find(i=>i.id===e);if(!s)return;const{questions:t}=b();t.value&&(s.max_points=t.value.reduce((i,c)=>i+(c.max_points??0),0))}async function S(e,s=!1){var H,J;const{user:t}=B();if(!m.value&&((H=t.value)==null?void 0:H.uid)===m.value){const K=(J=f.value)==null?void 0:J.find(U=>U.id===e);if(K)return K}const i=x(d,"tests",e),c=await k(i);if(!c.exists())return;const p=c.data();return p.id=c.id,s&&(p.questions=await Q(c.id)),p}async function I(e){if(m.value===e&&h.value===void 0)return;m.value=e;const s=w(d,"tests"),t=q(s,F("user_id","==",e)),i=await W(t);h.value=i.data().count}async function v(e){if(m.value===e&&f.value===void 0)return;const s=w(d,"tests"),t=q(s,F("user_id","==",e),R("updated_at","desc"),N(r)),i=await y(t);f.value=i.docs.map(c=>{const p=c.data();return p.id=c.id,p}),n=i.docs.length===0?null:i.docs[i.docs.length-1]}async function l(){if(!f.value||!n)return;const e=w(d,"tests"),s=q(e,F("user_id","==",m.value),R("updated_at","desc"),X(n),N(r)),t=await y(s),i=t.docs.map(c=>{const p=c.data();return p.id=c.id,p});n=t.docs.length===0?null:t.docs[t.docs.length-1],f.value=f.value.concat(i)}async function a(e){var i;const{user:s}=B();e.user_id=(i=s.value)==null?void 0:i.uid;const t=await z(w(d,"tests"),e);return e.id=t.id,e.updated_at=D.fromDate(new Date),f.value?f.value.unshift(e):f.value=[e],h.value?h.value++:h.value=1,t}async function o(e,s){if(await A(x(d,"tests",e),{name:s.name,description:s.description,time_limit:s.time_limit}),f.value){const t=f.value.findIndex(i=>i.id===e);if(t>-1){const i=f.value[t];i.name=s.name,i.description=s.description,i.time_limit=s.time_limit,i.updated_at=D.fromDate(new Date),t!=0&&(f.value.splice(t,1),f.value.unshift(i))}}}async function u(e){const s=x(d,"tests",e);if(await G(s),f.value){const i=f.value.findIndex(c=>c.id===e);i>-1&&f.value.splice(i,1)}h.value?h.value--:h.value=0;const t=w(d,"tests",e,"questions");await y(t).then(i=>{const c=[];return i.forEach(p=>{c.push(P(e,p.id))}),Promise.all(c)})}return{getTest:S,testCount:g(()=>h),tests:g(()=>f),loadTestCount:I,loadTests:v,loadMoreTests:l,addTest:a,updateTest:o,updateQuestionCount:T,updateMaxPoints:M,deleteTest:u}});export{b as a,O as b,E as u};
