import{M as G,r as g,x as E,a as A}from"./index-B1zD-M5g.js";import{u as H,d as R,g as J,c as q,q as M,o as F,w as T,b as I,e as K,T as L,f as z,h as N,i as W,a as X,l as U,s as Y}from"./firestore-qVOR4QEO.js";import{Q as Z}from"./Question-DJVAB3JS.js";const V=G("choiceService",()=>{const{db:h}=H(),_=g(),D=g(),e=g();async function C(w,m,f){var t;if(_.value===w&&D.value===m&&e.value){const n=(t=e.value)==null?void 0:t.find(s=>s.id===f);if(n)return n}const r=R(h,"tests",w,"questions",m,"choices",f),o=await J(r);if(o.exists()){const n=o.data();return n.id=o.id,n}}async function y(w,m){var n;const{user:f}=A(),r=q(h,"tests",w,"questions",m,"choices"),o=M(r,T("user_id","==",(n=f.value)==null?void 0:n.uid),F("position"));return(await I(o)).docs.map(s=>{const i=s.data();return i.id=s.id,i})}async function B(w,m){if(!m.id||_.value===w&&D.value===m.id&&e.value)return;_.value=w,D.value=m.id;const f=q(h,"tests",w,"questions",m.id,"choices"),r=M(f,T("user_id","==",m.user_id),F("position")),o=await I(r);e.value=o.docs.map(t=>{const n=t.data();return n.id=t.id,n})}async function S(w,m,f){var i;const{user:r}=A(),{updateMaxPoints:o}=j(),{incrementChoiceCount:t,updateMaxPoints:n}=k();f.user_id=(i=r.value)==null?void 0:i.uid;const s=await K(q(h,"tests",w,"questions",m,"choices"),f);if(f.id=s.id,f.updated_at=L.fromDate(new Date),e.value){e.value.unshift(f);let u=0;for(;u+1<e.value.length;){if(e.value[u].position>e.value[u+1].position){const a=e.value[u];e.value[u]=e.value[u+1],e.value[u+1]=a}u++}}return t(m),f.points&&f.points>0&&(n(m),o(w)),s}async function p(w,m,f,r){const{updateMaxPoints:o}=j(),{updateMaxPoints:t}=k();if(await z(R(h,"tests",w,"questions",m,"choices",f),{text:r.text,is_correct:r.is_correct,points:r.points,position:r.position}),e.value){const n=e.value.findIndex(s=>s.id===f);if(n>-1){const s=e.value[n];if(s.text=r.text,s.is_correct=r.is_correct,s.updated_at=L.fromDate(new Date),r.position>s.position){let i=n;for(;i+1<e.value.length;){if(r.position>e.value[i+1].position){const u=e.value[i];e.value[i]=e.value[i+1],e.value[i+1]=u}i++}}else if(r.position<s.position){let i=n;for(;i-1>=0;){if(r.position<e.value[i-1].position){const u=e.value[i];e.value[i]=e.value[i-1],e.value[i-1]=u}i--}}s.position=r.position,s.points!==r.points&&(s.points=r.points,t(m),o(w))}}}async function Q(w,m){if(e.value){const f=e.value.map(o=>o.position);let r=0;for(;r+1<f.length;){if(f[r]>f[r+1]){const o=f[r];f[r]=f[r+1],f[r+1]=o}r++}for(const[o,t]of e.value.entries())if(t.position!==f[o]&&t.id){const n=R(h,"tests",w,"questions",m,"choices",t.id);await z(n,{position:f[o]}),t.position=f[o]}}}async function P(w,m,f){const{updateMaxPoints:r}=j(),{decrementChoiceCount:o,updateMaxPoints:t}=k(),n=R(h,"tests",w,"questions",m,"choices",f);if(await N(n),e.value){const s=e.value.findIndex(i=>f===i.id);s>-1&&e.value.splice(s,1)}o(m),t(m),r(w)}return{choices:E(()=>e),getChoice:C,getChoices:y,loadChoices:B,addChoice:S,updateChoice:p,updateChoicesPositions:Q,deleteChoice:P}}),k=G("questionService",()=>{const{db:h}=H(),{getChoices:_}=V(),D=g(),e=g(),C=g();function y(o){var n;const t=(n=e.value)==null?void 0:n.find(s=>s.id===o);t&&(t!=null&&t.choiceCount?t.choiceCount++:t.choiceCount=1)}function B(o){var n;const t=(n=e.value)==null?void 0:n.find(s=>s.id===o);t!=null&&t.choiceCount&&t.choiceCount--}function S(o){if(!e.value)return;const t=e.value.find(i=>i.id===o);if(!t)return;const{choices:n}=V();if(!n.value)return;let s=0;t.type===Z.MultipleChoice?s=n.value.reduce((i,u)=>{const a=u.points??0;return a>0?i+a:i},0):s=n.value.reduce((i,u)=>Math.max(i,u.points??0),0),t.max_points=s}async function p(o,t){var i;D.value===o&&(C.value=(i=e.value)==null?void 0:i.find(u=>u.id===t));const n=R(h,"tests",o,"questions",t),s=await J(n);if(s.exists()){const u=s.data();u.id=s.id,C.value=u}}async function Q(o){var a;const{user:t}=A(),n=q(h,"tests",o,"questions"),s=M(n,T("user_id","==",(a=t.value)==null?void 0:a.uid),F("position")),i=[];return(await I(s).then(c=>{const l=[];return c.forEach(d=>{if(d.exists()){const v=d.data();v.id=d.id,i.push(v),l.push(_(o,d.id))}}),Promise.all(l)})).forEach((c,l)=>{i[l].choices=c}),i}async function P(o){if(!o.id||D.value===o.id)return;D.value=o.id;const t=q(h,"tests",o.id,"questions"),n=M(t,T("user_id","==",o.user_id),F("position")),s=await I(n);e.value=s.docs.map(i=>{const u=i.data();return u.id=i.id,u})}async function w(o,t){var u;const{user:n}=A(),{incrementQuestionCount:s}=j();t.user_id=(u=n.value)==null?void 0:u.uid;const i=await K(q(h,"tests",o.id,"questions"),t);if(t.id=i.id,t.updated_at=L.fromDate(new Date),e.value){e.value.unshift(t);let a=0;for(;a+1<e.value.length;){if(e.value[a].position>e.value[a+1].position){const c=e.value[a];e.value[a]=e.value[a+1],e.value[a+1]=c}a++}}return s(o.id),i}async function m(o,t,n){if(await z(R(h,"tests",o,"questions",t),{text:n.text,type:n.type,position:n.position}),e.value){const s=e.value.findIndex(i=>i.id===t);if(s>-1){const i=e.value[s];if(i.text=n.text,i.type=n.type,i.updated_at=L.fromDate(new Date),n.position>i.position){let u=s;for(;u+1<e.value.length;){if(n.position>e.value[u+1].position){const a=e.value[u];e.value[u]=e.value[u+1],e.value[u+1]=a}u++}}else if(n.position<i.position){let u=s;for(;u-1>=0;){if(n.position<e.value[u-1].position){const a=e.value[u];e.value[u]=e.value[u-1],e.value[u-1]=a}u--}}i.position=n.position}}}async function f(o){if(e.value){const t=e.value.map(s=>s.position);let n=0;for(;n+1<t.length;){let s=n;for(;s>-1&&t[s]>t[s+1];){const i=t[s];t[s]=t[s+1],t[s+1]=i,s--}n++}for(const[s,i]of e.value.entries())if(i.position!==t[s]&&i.id){const u=R(h,"tests",o,"questions",i.id);await z(u,{position:t[s]}),i.position=t[s]}}}async function r(o,t){var d;const{user:n}=A(),{decrementQuestionCount:s}=j(),i=R(h,"tests",o,"questions",t);if(await N(i),e.value){const v=e.value.findIndex(x=>t===x.id);v>-1&&e.value.splice(v,1)}s(o);const u=W(h),a=q(h,"tests",o,"questions",t,"choices"),c=M(a,T("user_id","==",(d=n.value)==null?void 0:d.uid));(await I(c)).forEach(v=>{u.delete(v.ref)}),await u.commit()}return{question:E(()=>C),questions:E(()=>e),getQuestions:Q,loadQuestion:p,loadQuestions:P,addQuestion:w,updateQuestion:m,updateQuestionsPositions:f,incrementChoiceCount:y,decrementChoiceCount:B,updateMaxPoints:S,deleteQuestion:r}}),j=G("testService",()=>{const{db:h}=H(),{deleteQuestion:_,getQuestions:D}=k(),{user:e}=A(),C=g(),y=g(),B=25;let S=null;const p=g(),Q=g(),P=g(180);function w(a){var l;const c=(l=p.value)==null?void 0:l.find(d=>d.id===a);c&&(c!=null&&c.questionCount?c.questionCount++:c.questionCount=1)}function m(a){var l;const c=(l=p.value)==null?void 0:l.find(d=>d.id===a);c!=null&&c.questionCount&&c.questionCount--}function f(a){if(!p.value)return;const c=p.value.find(d=>d.id===a);if(!c)return;const{questions:l}=k();l.value&&(c.max_points=l.value.reduce((d,v)=>d+(v.max_points??0),0))}async function r(a,c=!1){var l,d;if(e.value&&C.value===((l=e.value)==null?void 0:l.uid)&&p.value){const v=(d=p.value)==null?void 0:d.find(x=>x.id===a);v&&(Q.value=v)}if(!Q.value){const v=R(h,"tests",a),x=await J(v);if(!x.exists())return;const b=x.data();b.id=x.id,Q.value=b}if(c&&(Q.value.questions=await D(a),P.value=Q.value.time_limit,P.value>0)){let v=setInterval(()=>{P.value--,P.value===0&&(clearInterval(v),v=void 0)},1e3);return v}}async function o(){var d,v,x;if(C.value===((d=e.value)==null?void 0:d.uid)&&y.value!==void 0)return;C.value=(v=e.value)==null?void 0:v.uid;const a=q(h,"tests"),c=M(a,T("user_id","==",(x=e.value)==null?void 0:x.uid)),l=await X(c);y.value=l.data().count}async function t(){var d,v,x;if(C.value===((d=e.value)==null?void 0:d.uid)&&p.value)return;C.value=(v=e.value)==null?void 0:v.uid;const a=q(h,"tests"),c=M(a,T("user_id","==",(x=e.value)==null?void 0:x.uid),F("updated_at","desc"),U(B)),l=await I(c);p.value=l.docs.map(b=>{const O=b.data();return O.id=b.id,O}),S=l.docs.length===0?null:l.docs[l.docs.length-1]}async function n(){if(!p.value||!S)return;const a=q(h,"tests"),c=M(a,T("user_id","==",C.value),F("updated_at","desc"),Y(S),U(B)),l=await I(c),d=l.docs.map(v=>{const x=v.data();return x.id=v.id,x});S=l.docs.length===0?null:l.docs[l.docs.length-1],p.value=p.value.concat(d)}async function s(a){var d;const{user:c}=A();a.user_id=(d=c.value)==null?void 0:d.uid;const l=await K(q(h,"tests"),a);return a.id=l.id,a.updated_at=L.fromDate(new Date),p.value&&(p.value=[a,...p.value]),y.value?y.value++:y.value=1,l}async function i(a,c){if(await z(R(h,"tests",a),{name:c.name,description:c.description,time_limit:c.time_limit}),p.value){const l=p.value.findIndex(d=>d.id===a);if(l>-1){const d=p.value[l];d.name=c.name,d.description=c.description,d.time_limit=c.time_limit,d.updated_at=L.fromDate(new Date),l!=0&&(p.value=[d,...p.value.slice(0,l),...p.value.slice(l+1)])}}}async function u(a){const c=R(h,"tests",a);if(await N(c),p.value){const v=p.value.findIndex(x=>x.id===a);v>-1&&p.value.splice(v,1)}y.value&&y.value--;const l=q(h,"tests",a,"questions"),d=M(l,T("user_id","==",C.value));await I(d).then(v=>{const x=[];return v.forEach(b=>{x.push(_(a,b.id))}),Promise.all(x)})}return{test:E(()=>Q),time_limit:E(()=>P),testCount:E(()=>y),tests:E(()=>p),loadTest:r,loadTestCount:o,loadTests:t,loadMoreTests:n,addTest:s,updateTest:i,incrementQuestionCount:w,decrementQuestionCount:m,updateMaxPoints:f,deleteTest:u}});export{k as a,V as b,j as u};
