import{J as z,r as g,x as E,a as A}from"./index-CEw6Ur-o.js";import{u as G,d as R,g as H,c as q,q as T,o as F,w as M,b as I,e as K,T as L,f as j,h as N,i as W,a as X,l as U,s as Y}from"./firestore-O8Pw084e.js";import{Q as Z}from"./Question-DJVAB3JS.js";const V=z("choiceService",()=>{const{db:h}=G(),_=g(),D=g(),t=g();async function C(w,m,v){var e;if(_.value===w&&D.value===m&&t.value){const n=(e=t.value)==null?void 0:e.find(s=>s.id===v);if(n)return n}const r=R(h,"tests",w,"questions",m,"choices",v),o=await H(r);if(o.exists()){const n=o.data();return n.id=o.id,n}}async function y(w,m){var n;const{user:v}=A(),r=q(h,"tests",w,"questions",m,"choices"),o=T(r,M("user_id","==",(n=v.value)==null?void 0:n.uid),F("position"));return(await I(o)).docs.map(s=>{const i=s.data();return i.id=s.id,i})}async function B(w,m){if(!m.id||_.value===w&&D.value===m.id&&t.value)return;_.value=w,D.value=m.id;const v=q(h,"tests",w,"questions",m.id,"choices"),r=T(v,M("user_id","==",m.user_id),F("position")),o=await I(r);t.value=o.docs.map(e=>{const n=e.data();return n.id=e.id,n})}async function S(w,m,v){var i;const{user:r}=A(),{updateMaxPoints:o}=J(),{incrementChoiceCount:e,updateMaxPoints:n}=k();v.user_id=(i=r.value)==null?void 0:i.uid;const s=await K(q(h,"tests",w,"questions",m,"choices"),v);if(v.id=s.id,v.updated_at=L.fromDate(new Date),t.value){t.value.unshift(v);let u=0;for(;u+1<t.value.length;){if(t.value[u].position>t.value[u+1].position){const a=t.value[u];t.value[u]=t.value[u+1],t.value[u+1]=a}u++}}return e(m),v.points&&v.points>0&&(n(m),o(w)),s}async function p(w,m,v,r){const{updateMaxPoints:o}=J(),{updateMaxPoints:e}=k();if(await j(R(h,"tests",w,"questions",m,"choices",v),{text:r.text,is_correct:r.is_correct,points:r.points,position:r.position}),t.value){const n=t.value.findIndex(s=>s.id===v);if(n>-1){const s=t.value[n];if(s.text=r.text,s.is_correct=r.is_correct,s.updated_at=L.fromDate(new Date),r.position>s.position){let i=n;for(;i+1<t.value.length;){if(r.position>t.value[i+1].position){const u=t.value[i];t.value[i]=t.value[i+1],t.value[i+1]=u}i++}}else if(r.position<s.position){let i=n;for(;i-1>=0;){if(r.position<t.value[i-1].position){const u=t.value[i];t.value[i]=t.value[i-1],t.value[i-1]=u}i--}}s.position=r.position,s.points!==r.points&&(s.points=r.points,e(m),o(w))}}}async function Q(w,m){if(t.value){const v=t.value.map(o=>o.position);let r=0;for(;r+1<v.length;){if(v[r]>v[r+1]){const o=v[r];v[r]=v[r+1],v[r+1]=o}r++}for(const[o,e]of t.value.entries())if(e.position!==v[o]&&e.id){const n=R(h,"tests",w,"questions",m,"choices",e.id);await j(n,{position:v[o]}),e.position=v[o]}}}async function P(w,m,v){const{updateMaxPoints:r}=J(),{decrementChoiceCount:o,updateMaxPoints:e}=k(),n=R(h,"tests",w,"questions",m,"choices",v);if(await N(n),t.value){const s=t.value.findIndex(i=>v===i.id);s>-1&&t.value.splice(s,1)}o(m),e(m),r(w)}return{choices:E(()=>t),getChoice:C,getChoices:y,loadChoices:B,addChoice:S,updateChoice:p,updateChoicesPositions:Q,deleteChoice:P}}),k=z("questionService",()=>{const{db:h}=G(),{getChoices:_}=V(),D=g(),t=g(),C=g();function y(o){var n;const e=(n=t.value)==null?void 0:n.find(s=>s.id===o);e!=null&&e.choiceCount&&e.choiceCount++}function B(o){var n;const e=(n=t.value)==null?void 0:n.find(s=>s.id===o);e!=null&&e.choiceCount&&e.choiceCount--}function S(o){if(!t.value)return;const e=t.value.find(i=>i.id===o);if(!e)return;const{choices:n}=V();if(!n.value)return;let s=0;e.type===Z.MultipleChoice?s=n.value.reduce((i,u)=>{const a=u.points??0;return a>0?i+a:i},0):s=n.value.reduce((i,u)=>Math.max(i,u.points??0),0),e.max_points=s}async function p(o,e){var i;D.value===o&&(C.value=(i=t.value)==null?void 0:i.find(u=>u.id===e));const n=R(h,"tests",o,"questions",e),s=await H(n);if(s.exists()){const u=s.data();u.id=s.id,C.value=u}}async function Q(o){var a;const{user:e}=A(),n=q(h,"tests",o,"questions"),s=T(n,M("user_id","==",(a=e.value)==null?void 0:a.uid),F("position")),i=[];return(await I(s).then(l=>{const c=[];return l.forEach(d=>{if(d.exists()){const f=d.data();f.id=d.id,i.push(f),c.push(_(o,d.id))}}),Promise.all(c)})).forEach((l,c)=>{i[c].choices=l}),i}async function P(o){if(!o.id||D.value===o.id)return;D.value=o.id;const e=q(h,"tests",o.id,"questions"),n=T(e,M("user_id","==",o.user_id),F("position")),s=await I(n);t.value=s.docs.map(i=>{const u=i.data();return u.id=i.id,u})}async function w(o,e){var u;const{user:n}=A(),{incrementQuestionCount:s}=J();e.user_id=(u=n.value)==null?void 0:u.uid;const i=await K(q(h,"tests",o.id,"questions"),e);if(e.id=i.id,e.updated_at=L.fromDate(new Date),t.value){t.value.unshift(e);let a=0;for(;a+1<t.value.length;){if(t.value[a].position>t.value[a+1].position){const l=t.value[a];t.value[a]=t.value[a+1],t.value[a+1]=l}a++}}return s(o.id),i}async function m(o,e,n){if(await j(R(h,"tests",o,"questions",e),{text:n.text,type:n.type,position:n.position}),t.value){const s=t.value.findIndex(i=>i.id===e);if(s>-1){const i=t.value[s];if(i.text=n.text,i.type=n.type,i.updated_at=L.fromDate(new Date),n.position>i.position){let u=s;for(;u+1<t.value.length;){if(n.position>t.value[u+1].position){const a=t.value[u];t.value[u]=t.value[u+1],t.value[u+1]=a}u++}}else if(n.position<i.position){let u=s;for(;u-1>=0;){if(n.position<t.value[u-1].position){const a=t.value[u];t.value[u]=t.value[u-1],t.value[u-1]=a}u--}}i.position=n.position}}}async function v(o){if(t.value){const e=t.value.map(s=>s.position);let n=0;for(;n+1<e.length;){let s=n;for(;s>-1&&e[s]>e[s+1];){const i=e[s];e[s]=e[s+1],e[s+1]=i,s--}n++}for(const[s,i]of t.value.entries())if(i.position!==e[s]&&i.id){const u=R(h,"tests",o,"questions",i.id);await j(u,{position:e[s]}),i.position=e[s]}}}async function r(o,e){var d;const{user:n}=A(),{decrementQuestionCount:s}=J(),i=R(h,"tests",o,"questions",e);if(await N(i),t.value){const f=t.value.findIndex(x=>e===x.id);f>-1&&t.value.splice(f,1)}s(o);const u=W(h),a=q(h,"tests",o,"questions",e,"choices"),l=T(a,M("user_id","==",(d=n.value)==null?void 0:d.uid));(await I(l)).forEach(f=>{u.delete(f.ref)}),await u.commit()}return{question:E(()=>C),questions:E(()=>t),getQuestions:Q,loadQuestion:p,loadQuestions:P,addQuestion:w,updateQuestion:m,updateQuestionsPositions:v,incrementChoiceCount:y,decrementChoiceCount:B,updateMaxPoints:S,deleteQuestion:r}}),J=z("testService",()=>{const{db:h}=G(),{deleteQuestion:_,getQuestions:D}=k(),{user:t}=A(),C=g(),y=g(),B=25;let S=null;const p=g(),Q=g(),P=g(180);function w(a){var c;const l=(c=p.value)==null?void 0:c.find(d=>d.id===a);l!=null&&l.questionCount&&l.questionCount++}function m(a){var c;const l=(c=p.value)==null?void 0:c.find(d=>d.id===a);l!=null&&l.questionCount&&l.questionCount--}function v(a){if(!p.value)return;const l=p.value.find(d=>d.id===a);if(!l)return;const{questions:c}=k();c.value&&(l.max_points=c.value.reduce((d,f)=>d+(f.max_points??0),0))}async function r(a,l=!1){var c,d;if(t.value&&C.value===((c=t.value)==null?void 0:c.uid)&&p.value){const f=(d=p.value)==null?void 0:d.find(x=>x.id===a);f&&(Q.value=f)}if(!Q.value){const f=R(h,"tests",a),x=await H(f);if(!x.exists())return;const b=x.data();b.id=x.id,Q.value=b}if(l&&(Q.value.questions=await D(a),P.value=Q.value.time_limit,P.value>0)){let f=setInterval(()=>{P.value--,P.value===0&&(clearInterval(f),f=void 0)},1e3);return f}}async function o(){var d,f,x;if(C.value===((d=t.value)==null?void 0:d.uid)&&y.value!==void 0)return;C.value=(f=t.value)==null?void 0:f.uid;const a=q(h,"tests"),l=T(a,M("user_id","==",(x=t.value)==null?void 0:x.uid)),c=await X(l);y.value=c.data().count}async function e(){var d,f,x;if(C.value===((d=t.value)==null?void 0:d.uid)&&p.value)return;C.value=(f=t.value)==null?void 0:f.uid;const a=q(h,"tests"),l=T(a,M("user_id","==",(x=t.value)==null?void 0:x.uid),F("updated_at","desc"),U(B)),c=await I(l);p.value=c.docs.map(b=>{const O=b.data();return O.id=b.id,O}),S=c.docs.length===0?null:c.docs[c.docs.length-1]}async function n(){if(!p.value||!S)return;const a=q(h,"tests"),l=T(a,M("user_id","==",C.value),F("updated_at","desc"),Y(S),U(B)),c=await I(l),d=c.docs.map(f=>{const x=f.data();return x.id=f.id,x});S=c.docs.length===0?null:c.docs[c.docs.length-1],p.value=p.value.concat(d)}async function s(a){var d;const{user:l}=A();a.user_id=(d=l.value)==null?void 0:d.uid;const c=await K(q(h,"tests"),a);return a.id=c.id,a.updated_at=L.fromDate(new Date),p.value&&(p.value=[a,...p.value]),y.value?y.value++:y.value=1,c}async function i(a,l){if(await j(R(h,"tests",a),{name:l.name,description:l.description,time_limit:l.time_limit}),p.value){const c=p.value.findIndex(d=>d.id===a);if(c>-1){const d=p.value[c];d.name=l.name,d.description=l.description,d.time_limit=l.time_limit,d.updated_at=L.fromDate(new Date),c!=0&&(p.value=[d,...p.value.slice(0,c),...p.value.slice(c+1)])}}}async function u(a){const l=R(h,"tests",a);if(await N(l),p.value){const f=p.value.findIndex(x=>x.id===a);f>-1&&p.value.splice(f,1)}y.value&&y.value--;const c=q(h,"tests",a,"questions"),d=T(c,M("user_id","==",C.value));await I(d).then(f=>{const x=[];return f.forEach(b=>{x.push(_(a,b.id))}),Promise.all(x)})}return{test:E(()=>Q),time_limit:E(()=>P),testCount:E(()=>y),tests:E(()=>p),loadTest:r,loadTestCount:o,loadTests:e,loadMoreTests:n,addTest:s,updateTest:i,incrementQuestionCount:w,decrementQuestionCount:m,updateMaxPoints:v,deleteTest:u}});export{k as a,V as b,J as u};
