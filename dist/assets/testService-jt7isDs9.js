import{J as O,r as g,x as _,a as E,O as V}from"./index-Cr91u6jy.js";import{u as j,d as q,g as z,c as C,q as T,o as A,w as M,b as S,e as G,T as B,f as J,h as H,i as W,a as X,l as K,s as Y}from"./firestore-CQCayiu2.js";import{Q as Z}from"./Question-DJVAB3JS.js";const N=O("choiceService",()=>{const{db:p}=j(),I=g(),R=g(),e=g();async function x(h,v,r){var s;if(I.value===h&&R.value===v&&e.value){const o=(s=e.value)==null?void 0:s.find(i=>i.id===r);if(o)return o}const d=q(p,"tests",h,"questions",v,"choices",r),u=await z(d);if(u.exists()){const o=u.data();return o.id=u.id,o}}async function b(h,v){var o;const{user:r}=E(),d=C(p,"tests",h,"questions",v,"choices"),u=T(d,M("user_id","==",(o=r.value)==null?void 0:o.uid),A("position"));return(await S(u)).docs.map(i=>{const n=i.data();return n.id=i.id,n})}async function Q(h,v){if(!v.id||I.value===h&&R.value===v.id&&e.value)return;I.value=h,R.value=v.id;const r=C(p,"tests",h,"questions",v.id,"choices"),d=T(r,M("user_id","==",v.user_id),A("position")),u=await S(d);e.value=u.docs.map(s=>{const o=s.data();return o.id=s.id,o})}async function f(h,v,r){var n;const{user:d}=E(),{updateMaxPoints:u}=k(),{incrementChoiceCount:s,updateMaxPoints:o}=L();r.user_id=(n=d.value)==null?void 0:n.uid;const i=await G(C(p,"tests",h,"questions",v,"choices"),r);if(r.id=i.id,r.updated_at=B.fromDate(new Date),e.value){e.value.unshift(r);let t=0;for(;t+1<e.value.length;){if(e.value[t].position>e.value[t+1].position){const a=e.value[t];e.value[t]=e.value[t+1],e.value[t+1]=a}t++}}return s(v),r.points&&r.points>0&&(o(v),u(h)),i}async function y(h,v,r,d){const{updateMaxPoints:u}=k(),{updateMaxPoints:s}=L();if(await J(q(p,"tests",h,"questions",v,"choices",r),{text:d.text,is_correct:d.is_correct,points:d.points,position:d.position}),e.value){const o=e.value.findIndex(i=>i.id===r);if(o>-1){const i=e.value[o];if(i.text=d.text,i.is_correct=d.is_correct,i.updated_at=B.fromDate(new Date),d.position>i.position){let n=o;for(;n+1<e.value.length;){if(d.position>e.value[n+1].position){const t=e.value[n];e.value[n]=e.value[n+1],e.value[n+1]=t}n++}}else if(d.position<i.position){let n=o;for(;n-1>=0;){if(d.position<e.value[n-1].position){const t=e.value[n];e.value[n]=e.value[n-1],e.value[n-1]=t}n--}}i.position=d.position,i.points!==d.points&&(i.points=d.points,s(v),u(h))}}}async function D(h,v){if(e.value){const r=e.value.map(u=>u.position);let d=0;for(;d+1<r.length;){if(r[d]>r[d+1]){const u=r[d];r[d]=r[d+1],r[d+1]=u}d++}for(const[u,s]of e.value.entries())if(s.position!==r[u]&&s.id){const o=q(p,"tests",h,"questions",v,"choices",s.id);await J(o,{position:r[u]}),s.position=r[u]}}}async function F(h,v,r){const{updateMaxPoints:d}=k(),{decrementChoiceCount:u,updateMaxPoints:s}=L(),o=q(p,"tests",h,"questions",v,"choices",r);if(await H(o),e.value){const i=e.value.findIndex(n=>r===n.id);i>-1&&e.value.splice(i,1)}u(v),s(v),d(h)}return{choices:_(()=>e),getChoice:x,getChoices:b,loadChoices:Q,addChoice:f,updateChoice:y,updateChoicesPositions:D,deleteChoice:F}}),L=O("questionService",()=>{const{db:p}=j(),{getChoices:I}=N(),R=g(),e=g(),x=g();function b(u){var o;const s=(o=e.value)==null?void 0:o.find(i=>i.id===u);s&&(s!=null&&s.choiceCount?s.choiceCount++:s.choiceCount=1)}function Q(u){var o;const s=(o=e.value)==null?void 0:o.find(i=>i.id===u);s!=null&&s.choiceCount&&s.choiceCount--}function f(u){if(!e.value)return;const s=e.value.find(n=>n.id===u);if(!s)return;const{choices:o}=N();if(!o.value)return;let i=0;s.type===Z.MultipleChoice?i=o.value.reduce((n,t)=>{const a=t.points??0;return a>0?n+a:n},0):i=o.value.reduce((n,t)=>Math.max(n,t.points??0),0),s.max_points=i}async function y(u,s){var n;R.value===u&&(x.value=(n=e.value)==null?void 0:n.find(t=>t.id===s));const o=q(p,"tests",u,"questions",s),i=await z(o);if(i.exists()){const t=i.data();t.id=i.id,x.value=t}}async function D(u){var a;const{user:s}=E(),o=C(p,"tests",u,"questions"),i=T(o,M("user_id","==",(a=s.value)==null?void 0:a.uid),A("position")),n=[];return(await S(i).then(c=>{const l=[];return c.forEach(m=>{if(m.exists()){const w=m.data();w.id=m.id,n.push(w),l.push(I(u,m.id))}}),Promise.all(l)})).forEach((c,l)=>{n[l].choices=c}),n}async function F(u){if(!u.id||R.value===u.id)return;R.value=u.id;const s=C(p,"tests",u.id,"questions"),o=T(s,M("user_id","==",u.user_id),A("position")),i=await S(o);e.value=i.docs.map(n=>{const t=n.data();return t.id=n.id,t})}async function h(u,s){var t;const{user:o}=E(),{incrementQuestionCount:i}=k();s.user_id=(t=o.value)==null?void 0:t.uid;const n=await G(C(p,"tests",u.id,"questions"),s);if(s.id=n.id,s.updated_at=B.fromDate(new Date),e.value){e.value.unshift(s);let a=0;for(;a+1<e.value.length;){if(e.value[a].position>e.value[a+1].position){const c=e.value[a];e.value[a]=e.value[a+1],e.value[a+1]=c}a++}}return i(u.id),n}async function v(u,s,o){if(await J(q(p,"tests",u,"questions",s),{text:o.text,type:o.type,position:o.position}),e.value){const i=e.value.findIndex(n=>n.id===s);if(i>-1){const n=e.value[i];if(n.text=o.text,n.type=o.type,n.updated_at=B.fromDate(new Date),o.position>n.position){let t=i;for(;t+1<e.value.length;){if(o.position>e.value[t+1].position){const a=e.value[t];e.value[t]=e.value[t+1],e.value[t+1]=a}t++}}else if(o.position<n.position){let t=i;for(;t-1>=0;){if(o.position<e.value[t-1].position){const a=e.value[t];e.value[t]=e.value[t-1],e.value[t-1]=a}t--}}n.position=o.position}}}async function r(u){if(e.value){const s=e.value.map(i=>i.position);let o=0;for(;o+1<s.length;){let i=o;for(;i>-1&&s[i]>s[i+1];){const n=s[i];s[i]=s[i+1],s[i+1]=n,i--}o++}for(const[i,n]of e.value.entries())if(n.position!==s[i]&&n.id){const t=q(p,"tests",u,"questions",n.id);await J(t,{position:s[i]}),n.position=s[i]}}}async function d(u,s){var m;const{user:o}=E(),{decrementQuestionCount:i}=k(),n=q(p,"tests",u,"questions",s);if(await H(n),e.value){const w=e.value.findIndex(P=>s===P.id);w>-1&&e.value.splice(w,1)}i(u);const t=W(p),a=C(p,"tests",u,"questions",s,"choices"),c=T(a,M("user_id","==",(m=o.value)==null?void 0:m.uid));(await S(c)).forEach(w=>{t.delete(w.ref)}),await t.commit()}return{question:_(()=>x),questions:_(()=>e),getQuestions:D,loadQuestion:y,loadQuestions:F,addQuestion:h,updateQuestion:v,updateQuestionsPositions:r,incrementChoiceCount:b,decrementChoiceCount:Q,updateMaxPoints:f,deleteQuestion:d}}),k=O("testService",()=>{const{db:p}=j(),{deleteQuestion:I,getQuestions:R}=L(),{user:e}=E(),x=g(),b=25;let Q=null;const f=g(),y=g(),D=g(180);V(e,()=>{x.value=void 0,Q=null,f.value=void 0,y.value=void 0});function F(t){var c;const a=(c=f.value)==null?void 0:c.find(l=>l.id===t);a&&(a!=null&&a.questionCount?a.questionCount++:a.questionCount=1)}function h(t){var c;const a=(c=f.value)==null?void 0:c.find(l=>l.id===t);a!=null&&a.questionCount&&a.questionCount--}function v(t){if(!f.value)return;const a=f.value.find(l=>l.id===t);if(!a)return;const{questions:c}=L();c.value&&(a.max_points=c.value.reduce((l,m)=>l+(m.max_points??0),0))}async function r(t,a=!1){var c;if(e.value&&f.value){const l=(c=f.value)==null?void 0:c.find(m=>m.id===t);l&&(y.value=l)}if(!y.value){const l=q(p,"tests",t),m=await z(l);if(!m.exists())return;const w=m.data();w.id=m.id,y.value=w}if(a&&(y.value.questions=await R(t),D.value=y.value.time_limit,D.value>0)){let l=setInterval(()=>{D.value--,D.value===0&&(clearInterval(l),l=void 0)},1e3);return l}}async function d(){var l;if(!((l=e.value)!=null&&l.uid)||x.value!==void 0)return;const t=C(p,"tests"),a=T(t,M("user_id","==",e.value.uid)),c=await X(a);x.value=c.data().count}async function u(){var l;if(!((l=e.value)!=null&&l.uid)||f.value)return;const t=C(p,"tests"),a=T(t,M("user_id","==",e.value.uid),A("updated_at","desc"),K(b)),c=await S(a);f.value=c.docs.map(m=>{const w=m.data();return w.id=m.id,w}),Q=c.docs.length===0?null:c.docs[c.docs.length-1]}async function s(){var m;if(!((m=e.value)!=null&&m.uid)||!f.value||!Q)return;const t=C(p,"tests"),a=T(t,M("user_id","==",e.value.uid),A("updated_at","desc"),Y(Q),K(b)),c=await S(a),l=c.docs.map(w=>{const P=w.data();return P.id=w.id,P});Q=c.docs.length===0?null:c.docs[c.docs.length-1],f.value=f.value.concat(l)}async function o(t){var c;t.user_id=(c=e.value)==null?void 0:c.uid;const a=await G(C(p,"tests"),t);return t.id=a.id,t.updated_at=B.fromDate(new Date),f.value&&(f.value=[t,...f.value]),x.value?x.value++:x.value=1,a}async function i(t,a){if(await J(q(p,"tests",t),{name:a.name,description:a.description,time_limit:a.time_limit}),f.value){const c=f.value.findIndex(l=>l.id===t);if(c>-1){const l=f.value[c];l.name=a.name,l.description=a.description,l.time_limit=a.time_limit,l.updated_at=B.fromDate(new Date),c!=0&&(f.value=[l,...f.value.slice(0,c),...f.value.slice(c+1)])}}}async function n(t){var m;if(!((m=e.value)!=null&&m.uid))return;const a=q(p,"tests",t);if(await H(a),f.value){const w=f.value.findIndex(P=>P.id===t);w>-1&&f.value.splice(w,1)}x.value&&x.value--;const c=C(p,"tests",t,"questions"),l=T(c,M("user_id","==",e.value.uid));await S(l).then(w=>{const P=[];return w.forEach(U=>{P.push(I(t,U.id))}),Promise.all(P)})}return{test:_(()=>y),time_limit:_(()=>D),testCount:_(()=>x),tests:_(()=>f),loadTest:r,loadTestCount:d,loadTests:u,loadMoreTests:s,addTest:o,updateTest:i,incrementQuestionCount:F,decrementQuestionCount:h,updateMaxPoints:v,deleteTest:n}});export{L as a,N as b,k as u};
