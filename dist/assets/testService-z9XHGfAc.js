import{J as z,r as g,x as E,a as B}from"./index-D9eu1wvy.js";import{u as G,d as R,g as H,c as q,q as T,o as F,w as M,b as I,e as K,T as L,f as j,h as N,i as W,a as X,l as U,s as Y}from"./firestore-CkCHjU9t.js";import{Q as Z}from"./Question-DJVAB3JS.js";const V=z("choiceService",()=>{const{db:h}=G(),_=g(),D=g(),t=g();async function C(w,m,f){var e;if(_.value===w&&D.value===m&&t.value){const n=(e=t.value)==null?void 0:e.find(s=>s.id===f);if(n)return n}const d=R(h,"tests",w,"questions",m,"choices",f),o=await H(d);if(o.exists()){const n=o.data();return n.id=o.id,n}}async function y(w,m){var n;const{user:f}=B(),d=q(h,"tests",w,"questions",m,"choices"),o=T(d,M("user_id","==",(n=f.value)==null?void 0:n.uid),F("position"));return(await I(o)).docs.map(s=>{const i=s.data();return i.id=s.id,i})}async function A(w,m){if(!m.id||_.value===w&&D.value===m.id&&t.value)return;_.value=w,D.value=m.id;const f=q(h,"tests",w,"questions",m.id,"choices"),d=T(f,M("user_id","==",m.user_id),F("position")),o=await I(d);t.value=o.docs.map(e=>{const n=e.data();return n.id=e.id,n})}async function S(w,m,f){var i;const{user:d}=B(),{updateMaxPoints:o}=J(),{incrementChoiceCount:e,updateMaxPoints:n}=k();f.user_id=(i=d.value)==null?void 0:i.uid;const s=await K(q(h,"tests",w,"questions",m,"choices"),f);if(f.id=s.id,f.updated_at=L.fromDate(new Date),t.value){t.value.unshift(f);let u=0;for(;u+1<t.value.length;){if(t.value[u].position>t.value[u+1].position){const a=t.value[u];t.value[u]=t.value[u+1],t.value[u+1]=a}u++}}return e(m),f.points&&f.points>0&&(n(m),o(w)),s}async function p(w,m,f,d){const{updateMaxPoints:o}=J(),{updateMaxPoints:e}=k();if(await j(R(h,"tests",w,"questions",m,"choices",f),{text:d.text,is_correct:d.is_correct,points:d.points,position:d.position}),t.value){const n=t.value.findIndex(s=>s.id===f);if(n>-1){const s=t.value[n];if(s.text=d.text,s.is_correct=d.is_correct,s.updated_at=L.fromDate(new Date),d.position>s.position){let i=n;for(;i+1<t.value.length;){if(d.position>t.value[i+1].position){const u=t.value[i];t.value[i]=t.value[i+1],t.value[i+1]=u}i++}}else if(d.position<s.position){let i=n;for(;i-1>=0;){if(d.position<t.value[i-1].position){const u=t.value[i];t.value[i]=t.value[i-1],t.value[i-1]=u}i--}}s.position=d.position,s.points!==d.points&&(s.points=d.points,e(m),o(w))}}}async function Q(w,m){if(t.value){const f=t.value.map(o=>o.position);let d=0;for(;d+1<f.length;){if(f[d]>f[d+1]){const o=f[d];f[d]=f[d+1],f[d+1]=o}d++}for(const[o,e]of t.value.entries())if(e.position!==f[o]&&e.id){const n=R(h,"tests",w,"questions",m,"choices",e.id);await j(n,{position:f[o]}),e.position=f[o]}}}async function P(w,m,f){const{updateMaxPoints:d}=J(),{decrementChoiceCount:o,updateMaxPoints:e}=k(),n=R(h,"tests",w,"questions",m,"choices",f);if(await N(n),t.value){const s=t.value.findIndex(i=>f===i.id);s>-1&&t.value.splice(s,1)}o(m),e(m),d(w)}return{choices:E(()=>t),getChoice:C,getChoices:y,loadChoices:A,addChoice:S,updateChoice:p,updateChoicesPositions:Q,deleteChoice:P}}),k=z("questionService",()=>{const{db:h}=G(),{getChoices:_}=V(),D=g(),t=g(),C=g();function y(o){var n;const e=(n=t.value)==null?void 0:n.find(s=>s.id===o);e&&(e!=null&&e.choiceCount?e.choiceCount++:e.choiceCount=1)}function A(o){var n;const e=(n=t.value)==null?void 0:n.find(s=>s.id===o);e!=null&&e.choiceCount&&e.choiceCount--}function S(o){if(!t.value)return;const e=t.value.find(i=>i.id===o);if(!e)return;const{choices:n}=V();if(!n.value)return;let s=0;e.type===Z.MultipleChoice?s=n.value.reduce((i,u)=>{const a=u.points??0;return a>0?i+a:i},0):s=n.value.reduce((i,u)=>Math.max(i,u.points??0),0),e.max_points=s}async function p(o,e){var i;D.value===o&&(C.value=(i=t.value)==null?void 0:i.find(u=>u.id===e));const n=R(h,"tests",o,"questions",e),s=await H(n);if(s.exists()){const u=s.data();u.id=s.id,C.value=u}}async function Q(o){var a;const{user:e}=B(),n=q(h,"tests",o,"questions"),s=T(n,M("user_id","==",(a=e.value)==null?void 0:a.uid),F("position")),i=[];return(await I(s).then(c=>{const l=[];return c.forEach(r=>{if(r.exists()){const v=r.data();v.id=r.id,i.push(v),l.push(_(o,r.id))}}),Promise.all(l)})).forEach((c,l)=>{i[l].choices=c}),i}async function P(o){if(!o.id||D.value===o.id)return;D.value=o.id;const e=q(h,"tests",o.id,"questions"),n=T(e,M("user_id","==",o.user_id),F("position")),s=await I(n);t.value=s.docs.map(i=>{const u=i.data();return u.id=i.id,u})}async function w(o,e){var u;const{user:n}=B(),{incrementQuestionCount:s}=J();e.user_id=(u=n.value)==null?void 0:u.uid;const i=await K(q(h,"tests",o.id,"questions"),e);if(e.id=i.id,e.updated_at=L.fromDate(new Date),t.value){t.value.unshift(e);let a=0;for(;a+1<t.value.length;){if(t.value[a].position>t.value[a+1].position){const c=t.value[a];t.value[a]=t.value[a+1],t.value[a+1]=c}a++}}return s(o.id),i}async function m(o,e,n){if(await j(R(h,"tests",o,"questions",e),{text:n.text,type:n.type,position:n.position}),t.value){const s=t.value.findIndex(i=>i.id===e);if(s>-1){const i=t.value[s];if(i.text=n.text,i.type=n.type,i.updated_at=L.fromDate(new Date),n.position>i.position){let u=s;for(;u+1<t.value.length;){if(n.position>t.value[u+1].position){const a=t.value[u];t.value[u]=t.value[u+1],t.value[u+1]=a}u++}}else if(n.position<i.position){let u=s;for(;u-1>=0;){if(n.position<t.value[u-1].position){const a=t.value[u];t.value[u]=t.value[u-1],t.value[u-1]=a}u--}}i.position=n.position}}}async function f(o){if(t.value){const e=t.value.map(s=>s.position);let n=0;for(;n+1<e.length;){let s=n;for(;s>-1&&e[s]>e[s+1];){const i=e[s];e[s]=e[s+1],e[s+1]=i,s--}n++}for(const[s,i]of t.value.entries())if(i.position!==e[s]&&i.id){const u=R(h,"tests",o,"questions",i.id);await j(u,{position:e[s]}),i.position=e[s]}}}async function d(o,e){var r;const{user:n}=B(),{decrementQuestionCount:s}=J(),i=R(h,"tests",o,"questions",e);if(await N(i),t.value){const v=t.value.findIndex(x=>e===x.id);v>-1&&t.value.splice(v,1)}s(o);const u=W(h),a=q(h,"tests",o,"questions",e,"choices"),c=T(a,M("user_id","==",(r=n.value)==null?void 0:r.uid));(await I(c)).forEach(v=>{u.delete(v.ref)}),await u.commit()}return{question:E(()=>C),questions:E(()=>t),getQuestions:Q,loadQuestion:p,loadQuestions:P,addQuestion:w,updateQuestion:m,updateQuestionsPositions:f,incrementChoiceCount:y,decrementChoiceCount:A,updateMaxPoints:S,deleteQuestion:d}}),J=z("testService",()=>{const{db:h}=G(),{deleteQuestion:_,getQuestions:D}=k(),{user:t}=B(),C=g(),y=g(),A=25;let S=null;const p=g(),Q=g(),P=g(180);function w(a){var l;const c=(l=p.value)==null?void 0:l.find(r=>r.id===a);c&&(c!=null&&c.questionCount?c.questionCount++:c.questionCount=1)}function m(a){var l;const c=(l=p.value)==null?void 0:l.find(r=>r.id===a);c!=null&&c.questionCount&&c.questionCount--}function f(a){if(!p.value)return;const c=p.value.find(r=>r.id===a);if(!c)return;const{questions:l}=k();l.value&&(c.max_points=l.value.reduce((r,v)=>r+(v.max_points??0),0))}async function d(a,c=!1){var l,r;if(t.value&&C.value===((l=t.value)==null?void 0:l.uid)&&p.value){const v=(r=p.value)==null?void 0:r.find(x=>x.id===a);v&&(Q.value=v)}if(!Q.value){const v=R(h,"tests",a),x=await H(v);if(!x.exists())return;const b=x.data();b.id=x.id,Q.value=b}if(c&&(Q.value.questions=await D(a),P.value=Q.value.time_limit,P.value>0)){let v=setInterval(()=>{P.value--,P.value===0&&(clearInterval(v),v=void 0)},1e3);return v}}async function o(){var r,v,x;if(C.value===((r=t.value)==null?void 0:r.uid)&&y.value!==void 0)return;C.value=(v=t.value)==null?void 0:v.uid;const a=q(h,"tests"),c=T(a,M("user_id","==",(x=t.value)==null?void 0:x.uid)),l=await X(c);y.value=l.data().count}async function e(){var r,v,x;if(C.value===((r=t.value)==null?void 0:r.uid)&&p.value)return;C.value=(v=t.value)==null?void 0:v.uid;const a=q(h,"tests"),c=T(a,M("user_id","==",(x=t.value)==null?void 0:x.uid),F("updated_at","desc"),U(A)),l=await I(c);p.value=l.docs.map(b=>{const O=b.data();return O.id=b.id,O}),S=l.docs.length===0?null:l.docs[l.docs.length-1]}async function n(){if(!p.value||!S)return;const a=q(h,"tests"),c=T(a,M("user_id","==",C.value),F("updated_at","desc"),Y(S),U(A)),l=await I(c),r=l.docs.map(v=>{const x=v.data();return x.id=v.id,x});S=l.docs.length===0?null:l.docs[l.docs.length-1],p.value=p.value.concat(r)}async function s(a){var l;a.user_id=(l=t.value)==null?void 0:l.uid;const c=await K(q(h,"tests"),a);return a.id=c.id,a.updated_at=L.fromDate(new Date),p.value&&(p.value=[a,...p.value]),y.value?y.value++:y.value=1,c}async function i(a,c){if(await j(R(h,"tests",a),{name:c.name,description:c.description,time_limit:c.time_limit}),p.value){const l=p.value.findIndex(r=>r.id===a);if(l>-1){const r=p.value[l];r.name=c.name,r.description=c.description,r.time_limit=c.time_limit,r.updated_at=L.fromDate(new Date),l!=0&&(p.value=[r,...p.value.slice(0,l),...p.value.slice(l+1)])}}}async function u(a){const c=R(h,"tests",a);if(await N(c),p.value){const v=p.value.findIndex(x=>x.id===a);v>-1&&p.value.splice(v,1)}y.value&&y.value--;const l=q(h,"tests",a,"questions"),r=T(l,M("user_id","==",C.value));await I(r).then(v=>{const x=[];return v.forEach(b=>{x.push(_(a,b.id))}),Promise.all(x)})}return{test:E(()=>Q),time_limit:E(()=>P),testCount:E(()=>y),tests:E(()=>p),loadTest:d,loadTestCount:o,loadTests:e,loadMoreTests:n,addTest:s,updateTest:i,incrementQuestionCount:w,decrementQuestionCount:m,updateMaxPoints:f,deleteTest:u}});export{k as a,V as b,J as u};
